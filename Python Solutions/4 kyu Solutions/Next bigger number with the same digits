Create a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:

12 ==> 21
513 ==> 531
2017 ==> 2071
nextBigger(num: 12)   // returns 21
nextBigger(num: 513)  // returns 531
nextBigger(num: 2017) // returns 2071
If the digits can't be rearranged to form a bigger number, return -1 (or nil in Swift):

9 ==> -1
111 ==> -1
531 ==> -1
nextBigger(num: 9)   // returns nil
nextBigger(num: 111) // returns nil
nextBigger(num: 531) // returns nil





from functools import lru_cache
@lru_cache()
def next_bigger(num):
    first = arr = list(map(int,str(num)))
    n = len(arr)
    k = n - 2
    while k >= 0:
        if arr[k] < arr[k + 1]:
            break
        k -= 1
    if k < 0:
        arr = arr[::-1]
    else:
        for l in range(n - 1, k, -1):
            if arr[l] > arr[k]:
                break
        arr[l], arr[k] = arr[k], arr[l]
        arr[k + 1:] = reversed(arr[k + 1:])
    return int(''.join(map(str,arr))) if int(''.join(map(str,arr)))>num else -1
