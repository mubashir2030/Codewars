This is a hard version of How many are smaller than me?. If you have troubles solving this one, have a look at the easier kata first.

Write

function smaller(arr)
that given an array arr, you have to return the amount of numbers that are smaller than arr[i] to the right.

For example:

smaller([5, 4, 3, 2, 1]) === [4, 3, 2, 1, 0]
smaller([1, 2, 0]) === [1, 1, 0]



#Solution

import random

def smaller(arr):
    solution = [0]
    ordered = SkipList()
    ordered.insert(arr[-1])
    #print(ordered)
    for i in range(len(arr)-2, -1, -1):
        num = arr[i]
        insert_index = ordered.insert(num)
        #print(ordered)
        solution.append(insert_index)
    return [solution[i] for i in range(len(solution)-1, -1, -1)]
    
class SkipList():
    def __init__(self):
        self.root = SkipListElement("ROOT", height=1)
        self.length = 0
    
    def insert(self, value):
        #print("insert", value)
        current_level = self.root.height - 1
        current_element = self.root
        skipped = 0
        prevs = dict()
        while current_level >= 0:
            prevs[current_level] = current_element
            current_skipped = current_element.widths[current_level]
            current_element = current_element.nexts[current_level]
            if current_element is None or value < current_element.value:
                current_element = prevs[current_level]
                current_level -= 1 
            else:
                skipped += current_skipped
        
        self.length += 1
        if value == prevs[0].value:
            for lvl in prevs:
                prevs[lvl].widths[lvl] += 1
            return skipped - 1
        
        skipped = skipped + prevs[0].widths[0] - 1 
        new_element = SkipListElement(value)
        for lvl in range(self.root.height):
            if lvl < new_element.height:
                prevs[lvl].nexts[lvl], new_element.nexts[lvl] = new_element, prevs[lvl].nexts[lvl]
                if lvl > 0:
                    cur_lvl = lvl - 1
                    cur_ele = new_element
                    cur_width = 0
                    while cur_ele is not None and cur_ele != new_element.nexts[lvl]:
                        cur_width += cur_ele.widths[cur_lvl]
                        cur_ele = cur_ele.nexts[cur_lvl]
                    new_element.widths[lvl] = cur_width
                    prevs[lvl].widths[lvl] -= cur_width - 1
            else:
                prevs[lvl].widths[lvl] += 1
        while new_element.height > self.root.height:
            self.root.nexts.append(new_element)
            self.root.widths.append(skipped+1)
            new_element.widths[self.root.height] = self.length - skipped
            self.root.height += 1
        return skipped

    def __str__(self):
        levels = ["R"+"-"*(w-1) for w in self.root.widths]
        for lvl, head in enumerate(self.root.nexts):
            elem = head
            while elem is not None:
                levels[lvl] += str(elem.value)[-1] + "-"*(elem.widths[lvl]-1)
                elem = elem.nexts[lvl]
        return "SkipList\n" + "\n".join(levels) + "\n"

class SkipListElement():
    def __init__(self, value, height=0):
        self.value = value
        if height:
            self.height = height
        else:
            self.height = 1
            while random.choice([0,1]) :
                self.height += 1
        self.nexts = [None for _ in range(self.height)]
        self.widths = [1 for _ in range(self.height)]
    
    def __str__(self):
        return str(self.value)
